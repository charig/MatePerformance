## This file defines common functions used for data processing.
load_metrics_file <- function(benchmark_name, iter, data_set) {
  filename <- paste0("/../Data/Metrics/", benchmark_name, "-", iter, "/", data_set, ".csv")
  read.table(filename, sep="\t", header=TRUE, fill=TRUE, comment.char = "")
}

load_data_file <- function (file, row_names) {
  if (missing(row_names)) {
    # these row names are hard coded and might not be applicable
    # names like this are generated by ReBench
    row_names <- c("?", "Iteration", "Value", "Unit", "Criterion", "Benchmark",
                   "VM", "Suite", "InputSize", "Var", "Warmup?", "Cores?")
  }
  
  bench <- read.table(file, sep="\t", header=FALSE, col.names=row_names, fill=TRUE)
  bench
}

getAndPrepareData <- function(filename, filterColumns) {
  data <- load_data_file(filename)
  if (!missing(filterColumns)) {
    data <- subset(data, select=filterColumns)
  }
  data
}

change_names <- function(data, name_map, column) {
  levels(data[,column])  <- map_names(
    levels(data[,column]),
    name_map)
  data
}

map_names <- function(old_names, name_map) {
  for (i in 1:length(old_names)) {
    old_name <- old_names[[i]]
    if (old_name %in% names(name_map)) {
      old_names[i] <- name_map[[old_name]]
    }
  }
  old_names
}

getRawData <- function(filenames, filterColumns, vmNames, keepVMs, maxIteration, changeBenchNames) {
  data <- matrix(nrow = 0, ncol = 0)
  for(filename in filenames) {
    preliminaryData <- getAndPrepareData(filename, filterColumns)
    preliminaryData <- change_names(preliminaryData, vmNames, "VM")
    if (!missing(changeBenchNames))
      preliminaryData <- change_names(preliminaryData, changeBenchNames, "Benchmark")
    preliminaryData <- droplevels(subset(preliminaryData, VM %in% keepVMs))
    if (!missing(maxIteration))
      preliminaryData <- droplevels(subset(preliminaryData, Iteration <= maxIteration))  
    if (nrow(data) == 0)
      data <- preliminaryData
    else {
      data <- rbind(data, preliminaryData)
    }
  }
  return(data)
}

getFilteredData <- function(filename, filterColumns, vmNames, keepVms, iterationsFilename, iterationsColNames, numberOfIterations) {
  data <- getRawData(filename, filterColumns, vmNames, keepVms)
  steady <- selectIterationsAndInlining(data, iterationsFilename, iterationsColNames, numberOfIterations)
  steady
}

getWarmedupData <- function(filenames, filterColumns, vmNames, keepVms, numberOfIterations, changeBenchNames) {
  data <- getRawData(filenames, filterColumns, vmNames, keepVms, changeBenchNames = changeBenchNames)
  #steady <- selectWarmedupData(data, numberOfIterations)
  steady <- selectDataLast(data, numberOfIterations)
  steady
}

getWarmupData <- function(filename, filterColumns, vmNames, keepVms, numberOfIterations) {
  data <- getRawData(filename, filterColumns, vmNames, keepVms)
  steady <- selectWarmupData(data, numberOfIterations)
  steady
}

selectWarmedupData <- function(data, numberOfIterations) {
  return (selectData(data, numberOfIterations, TRUE))
}

selectWarmupData <- function(data, numberOfIterations) {
  return (selectData(data, 0, FALSE))
}

selectDataLast <- function(data, numberOfIterations) {
  return (droplevels(subset(data, Iteration >= max(Iteration) - numberOfIterations + 1)))  
}  

selectData <- function(data, numberOfIterations, warmedup) {
  resultSet <- data
  for (vm in unique(data$VM)){
    filename <- paste("../Warmups/", warmupFilename(vm), sep="")
    warmups <- read.delim(paste("../Warmups/", warmupFilename(vm), sep=""), header = FALSE, skip=0)
    for (b in unique(data$Benchmark)) {
      row <- warmups[warmups$V1 == b,]
      if (nrow(row) == 0) {
        if (b != "CD"){
          "This because CD do not run in Pharo"
          print ("Benchmark removed because there is no row for it in the changepoint file")
          print (b)
          print (vm)
          resultSet <- droplevels(subset(resultSet, Benchmark != b))
        }
      } else {
        realValues <- suppressWarnings(as.numeric(row))
        realValues <- realValues[!is.na(row)]
        realValues <- realValues[realValues != '']
        warmup <- tail(realValues, n=1)
        if (warmup != -1){
          if (warmedup){
            resultSet <- droplevels(subset(resultSet,(
              (Benchmark != b) | (VM != vm) |
                (Benchmark == b & VM == vm & Iteration >= warmup + 3 & Iteration < warmup + numberOfIterations))))
          } else {
            resultSet <- droplevels(subset(resultSet,(
              (Benchmark != b) | (VM != vm) |
                (Benchmark == b & VM == vm & Iteration <= warmup + 2))))
          }
        } else {
          #No automatic warmup. Look for a manual one.
          warmupsManual <- read.delim(paste("../Warmups/", "changePoint-manual.tsv", sep=""), sep="\t", header = FALSE, skip=2)
          row <- warmupsManual[warmupsManual$V1 == vm & warmupsManual$V2 == b,]
          if (nrow(row) == 0) {
            print (paste(paste("Missing manual warmup value for", vm), b))  
          } else {
            warmup <- suppressWarnings(tail(as.numeric(row), n=1))
            if (warmedup){
              resultSet <- droplevels(subset(resultSet,(
                (Benchmark != b) | (VM != vm) |
                  (Benchmark == b & (VM == vm) & Iteration >= warmup + 3 & Iteration < warmup + numberOfIterations))))
            } else {
              resultSet <- droplevels(subset(resultSet,(
                (Benchmark != b) | (VM != vm) |
                  (Benchmark == b & (VM == vm) & Iteration <= warmup + 2))))
            }
          }  
        }
      }
    }
  }
  return (resultSet)
}


microBenchmarks <- c("Bounce", "List", "Mandelbrot", "NBody", "Permute", "Queens", "Sieve", "Storage", "Towers", "Fibonacci", "Recurse")
macroBenchmarks <- c("CD", "DeltaBlue", "Havlak", "Json", "Richards")

mtVMs <- c("SOMmt", "MATEmt", "MATEmt-obj")
peVMs <- c("SOMpe", "SOMpe-Ent", "MATEpe", "MATEpe-obj")

tracingBenchmarks <- c("QuickSort", "NBody", "DeltaBlue", "JsonBig")

#Name mappings

vmNamesMap <- function() {
  return (list(
    "Java"                                  = "Java11",
    #"GraalJS"                              = "JavaScript, GraalJS",
    "Node"                                  = "Node.js",
    "TruffleSOM"                            = "SOMpe",
    "TruffleMate"                           = "MATEpe",
    "RTruffleSOM"                           = "SOMmt",
    "RTruffleMate"                          = "MATEmt",
    "RTruffleMate-envInObject"              = "MATEmt-obj",
    "TruffleMate-envInObject"               = "MATEpe-obj",
    "TruffleMate-graal-enterprise-naive"    = "MATEpe-noOpt",
    "Pharo"                                 = "Pharo"))
}

individual_benchs_name_map <- 
  list(
    "LayoutFieldRead"		 = "FieldRead",
    "LayoutFieldWrite"	 = "FieldWrite",
    "ArgumentRead"	     = "ArgRead",
    "LocalVariableRead"	 = "LocalRead",
    "LocalVariableWrite" = "LocalWrite",
    "MessageSend"			   = "Send",
    "MethodActivation" 	 = "Activation",
    "AllOperations" 		 = "All",
    "SeveralObjectsFieldRead" 	= "Mega2",
    "SeveralObjectsFieldReadOneMO" 	= "Mono2",
    "SeveralObjectsFieldRead2" 	= "Mega",
    "SeveralObjectsFieldReadOneMO2" = "Mono"
  )

readonly_benchs_name_map <- 
  list(
    "DelegationProxiesSumKeys" = "Proxies", 
    "ReadonlySumKeys"	 = "MOP")